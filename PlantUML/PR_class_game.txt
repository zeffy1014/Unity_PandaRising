@startuml
title ゲーム画面(ざっくり)
skinparam classAttributeIconSize 0

package GameState {
    interface IStateEventReceiver {
        + OnStart()
        + OnPlayerDefeated()
        + OnHouseDestroyed()
        + OnBossDefeated()
        + OnRetry()
    }
    note top of IStateEventReceiver : 状態遷移トリガー\nこれを受けて状態遷移し\nその変化をReactivePropertyで参照させる

    enum GameState {
        Ready
        Play
        Pause
        GameOver
        StageClear
    }
    class GameStateProperty {
        + {static} IReadOnlyReactiveProperty<GameState> state
    }

    GameStateProperty --* GameState
    GameStateProperty -up-|> IStateEventReceiver
}

package Bullet {
    class Bullet {
        - int size
        - float speed
    }
    enum BulletType {
        Player_Mikan : メインショット
        Player_Sakana : サブウェポン(魚)
        Player_Block : サブウェポン(岩)
        Player_Kaju : 果汁レーザー
        Enemy_Point
        Enemy_Needle
        Enemy_xxx
    }
    Bullet -* BulletType
}

class GameController {
    + IReadOnlyReactiveProperty<int> Score
    + IReadOnlyReactiveProperty<int> Combo
    + IReadOnlyReactiveProperty<int> Hight
    + IReadOnlyReactiveProperty<int> Money
    + IReadOnlyReactiveProperty<float> RiseSpeed
    + IReadOnlyReactiveProperty<xxx> ...and more!
    + OnPauseMenu(bool)
}

class GameArea {
    + void GetArea()
    + Vector2 GetPosFromRate(Vector2 rate)
    + Rect GetAreaRect()
}
note bottom of GameArea : ゲームウィンドウの範囲取得・\n縦横割合指定で座標取得など

package DataBase {
    class DataLibrarian{
        + GetLibrarian() : インスタンス取得
        + StageInfo GetStageInfo(StageNumber)
        + 各種UserDataのGet()
   }
    note right of DataLibrarian : ゲーム起動時にJSONで各種情報を読み込んで\n情報取得IFを提供する

    class UniversalData {
        - List Stage構成情報[Stage_Num]
     }
     note bottom of UniversalData : 変わることのないデータ\nリソースの一部として保持

    class StageInfo {
        - StageNumber stage
        - string 敵生成テーブルの格納パス
        - string 背景画像の格納パス
        - string BGMの格納パス(ステージ・ボス)
        - int Start高度
        - int Goal高度
    }
    class ReinforcementTableInfo {
        - int[] shotPowerTable : 強化レベルに対するショット威力
        - int[] shotRapidityTable : 強化レベルに対する連射力
        - int[] houseDurabilityTable : 強化レベルに対する家のライフ最大値
        - ...
    }
    enum StageNumber {
        Tutorial,
        Stage1,
        Stage2,
        Stage3,
        Stage4,
        Stage5,

        Stage_Num
    }

    class UserData {
        - Playerの各種強化レベル
        - Houseの各種強化レベル
        - 上昇速度倍率上限
        - コンティニュー上限回数
        - ハイスコア
        - 所持金
    }
    note bottom of UserData : 強化などで変わっていくデータ

    DataLibrarian *-- UniversalData
    DataLibrarian *-- UserData

}

class Player {
    + IReadOnlyReactiveProperty<int> life
    + IReadOnlyReactiveProperty<int> bomb
}


package InputProvider {
    class InputPresenter {
    }

    interface IInputProvider {
    }
    note top of IInputProvider : PCか携帯かなどで\n紐づける入力方法を変える\n生の入力値を操作に変換

    class TouchInputProvider {
    }
    class PCInputProvider {
    }

    TouchInputProvider -up-|> IInputProvider
    PCInputProvider -up-|> IInputProvider

    package OperationHandler(MonoBehaviour) {
        class MouseOperation {}
        class KeyOperation {}
        class TouchOperation {}
    }
}

class House {
    + IReadOnlyReactiveProperty<int> life
}

package Enemy {
    class EnemyGenerator {}
    class Enemy {}
    Enemy_A -up-|> Enemy
    Enemy_B -up-|> Enemy

    class Block {
        + onGrab()
        + onRelease()
    }
    Block -up-|> Enemy
    note top of Block : 弾では撃破できず\n触れても被弾せず押したり\n掴んで投げたりできる特殊な敵
}

package UI {
    enum ButtonType {
        Shot
        Throw
        Bomb
        Menu
    }
    class OperateButton {
    }
    OperateButton -right* ButtonType
    class SlideArea{}
    class ThrowButtonView{}
    class BombButtonView{}

    class ScoreBoard {
        + Score
        + HighScore
    }
    class HightMetor {}
    class SpeedMetor {
        + SpeedMagnification
    }
    class PlayTime {}
    class Combo {}

    class LifeGauge {
        + PlayerLife
        + HouseLife
    }
    class UIPresenter {

    }
}


package UnityEngine {
    class Input {}
}

/'依存関係'/
InputPresenter --> IInputProvider : 各種操作をSubscribe
TouchInputProvider --> TouchOperation : タッチ操作をSubscribe
TouchInputProvider -> OperateButton : 各種ボタン操作をSubscribe
TouchInputProvider -> SlideArea : スライド操作をSubscribe
PCInputProvider --> MouseOperation : マウス/キーボード入力を\nSubscribe
PCInputProvider --> KeyOperation : キーボード入力を\nSubscribe
KeyOperation --> Input
MouseOperation --> Input
TouchOperation --> Input

InputPresenter --> Player : 状態に応じた操作入力
InputPresenter --> GameController : 状態に応じた操作入力

Player --> Bullet
Enemy --> Bullet
EnemyGenerator --> Enemy : 生成

Player .> GameArea : (移動範囲として)ゲームウィンドウ範囲参照

UIPresenter ..> GameController : 各種表示情報参照
note on link : 各種情報\n・コンボ\n・現在高度\n・上昇速度倍率\n・スコア\n・所持金\n・時間\n・etc...
UIPresenter ..> Player : HP・ボム数・状態参照
UIPresenter ..> House : HP参照

GameController .> GameStateProperty : 状態参照
Player .> GameStateProperty : 状態参照
House .> GameStateProperty : 状態参照
InputPresenter .> GameStateProperty : 状態参照
EnemyGenerator ..> GameController : 現在高度参照

UIPresenter --up> BombButtonView : ボム数表示
UIPresenter --up> ThrowButtonView : 投げ状態表示
UIPresenter --up> LifeGauge : HP表示
UIPresenter --up> HightMetor : 現在高度表示
UIPresenter --up> SpeedMetor : 上昇速度倍率表示
UIPresenter --up> ScoreBoard : スコアと所持金表示
UIPresenter --up> Combo : コンボ数表示
UIPresenter --up> PlayTime : プレイ時間表示


@enduml

◆playerとして毎フレーム取得したい入力情報(IInputProviderが提供するIF)
・ショット用の操作がされているか
　　マウスの場合は左クリック押下
　　タッチの場合は[みかん]タッチ押下
・サブ用の操作がされているか
　　マウスの場合は右クリック押下後の離され(方向)
　　タッチの場合は[魚]タッチ押下後の離され(方向)
・移動量
　　マウスの場合は前回フレームと今回フレームのカーソル移動量
　　タッチの場合は前回フレームと今回フレームの移動用タッチの移動量

InputDALというのはInput Device Abstraction Layer という造語
移動量に対する実際の移動距離の調整、ショット操作に対する発射間隔の調整などは
player側で実施する

OperationButtonではボタンの押され表現も自前で行う
ただしボタンが状況によって押せないなど非アクティブ表現する場合の対策
案１：
　別のClassを用意してGameControllerなどから情報取得して対応する
　マウスだったらクリックはいつでもできる、ただし反応するかはゲームの状況次第
　何も反応しないか、あるいはBeep音出して操作不可を表現することもありうる
案２：
　OperationButtonを利用するPlayer側から情報を伝えて表現変えてもらう

◆情報参照・受け渡しの依存関係対応
